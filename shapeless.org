#+title:  入門⚡Shapeless
#+author: Windymelt
#+date:   2022-12-12

#+html_head: <style> @font-face {font-family: "Berkeley Mono"; src: url("https://www.3qe.us/webfont/BerkeleyMono-Regular.woff2") format("woff2"), url("https://www.3qe.us/webfont/BerkeleyMono-Regular.woff") format("woff");} </style>

#+html_head: <style> p { line-height:1.2; } pre, code { font-family: Berkeley Mono; } </style>
#+html_head: <style>table {margin-left:auto; margin-right:auto;}</style>

#+begin_center
#+begin_export html
<a href="https://b.hatena.ne.jp/entry/" class="hatena-bookmark-button" data-hatena-bookmark-layout="vertical-normal" data-hatena-bookmark-lang="en" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/v4/public/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a><script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
#+end_export
#+end_center

* 入門⚡Shapeless

#+begin_export html
<link rel="stylesheet"
      href="./highlight/styles/mono-blue.min.css">
<script src="./highlight/highlight.min.js"></script>
#+end_export

** はじめに

この記事では、プログラミング言語 [[https://scala-lang.org][Scala]] において *ジェネリックプログラミング(Generic Programming)* を行うためのライブラリである *[[https://github.com/milessabin/shapeless][shapeless]]* の基本的な利用方法を解説します。

*** この記事で使うshapelessについて

この記事は、 shapeless 2.3.5 に基いて執筆されています。当該バージョンのshapelessは、 =build.sbt= において以下のようにインストールできます:

#+begin_example scala
libraryDependencies += "com.chuusai" %% "shapeless" % "2.3.5"
#+end_example

*** この記事で使うScalaについて

この記事は、Scala 2.13.8に基いて執筆されています。Scala 3系においてもshapelessを利用することはできますが、執筆時点で筆者はScala 3に関する知識を十分に持ち合わせていませんから、Scala 3における動作に関する記述は割愛します。

** ジェネリックプログラミングとは

ジェネリックプログラミングとは、ある問題領域における *構造* を表現する手段として具体的なclassやtraitを使わず、より抽象的な道具を用いて構造を表現するプログラミング手法です。

また、ジェネリックプログラミングは、JavaやScalaにおけるジェネリクス / Parametarized Typesとは関係ないため注意が必要です。

*** <<genericquote>>ジェネリックプログラミング(shapeless)が必要になる例

- 同じ型の要素を同じ順序で持つcase class同士を相互変換する
- 異なる型が混在し、なおかつ型安全な =Map= を利用する

いずれにせよ、ジェネリックプログラミングとは、クラスや型といった具体的な要素から「構造」という要素を取り出し、それ単体で物事をうまく扱おうという考え方を指しています。
ジェネリップログラミングを使うと、構造と構成要素の型を維持しつつ、 =class= や =trait=
の垣根を飛び越えてデータを操作できるようになります。

** Shapelessに登場する基礎概念

Shapelessでは、型同士を組み合わせたり取り出したりします。この節では、この目的を達成するために用意されている道具のうち基礎的なものを紹介します。代数的データ型について知っている場合は読み飛ばしてかまいません。

*** 代数的データ型(ADTs)

先程、 [[genericquote]] で以下のように述べました。

#+begin_quote
ジェネリックプログラミングとは、クラスや型といった具体的な要素から「構造」という要素を取り出し、それ単体で物事をうまく扱おうという考え方を指しています。
#+end_quote

では、 *構造* とは何でしょう。数学的な難しい話は割愛しますが、 *代数的データ型(Algebraic Data Types, ADTs)* を用いることで再帰を含む複雑な持ったデータ型を表現できることがわかっています。
そして、多くの言語ではこのADTsを言語レベルである程度サポートするための機能が備えられており、Scalaもこうした言語のうちの一つです。

ADTsは、 **直積(Product)** と **直和(Coproduct、 余積とも)** から成るデータ型の総称です。
数学的な詳細な説明は割愛しますが、直積は複数のデータ型をくっつけて _両方のデータを同時に表現できるようにした_ ものであり、直和は複数のデータ型をくっつけて _このうちどれか一つを表現できるようにした_ ものです。
この2つを組み合わせることでADTsは様々な抽象的なデータ型を表現する能力を得ます。

例えば、よく知られたデータ構造である[[https://ja.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%9C%A8][二分木]]は「木か葉[fn::木構造において、それ以上木構造が深くならないような部分のことを葉と呼びます。]のいずれか」という直和型を2つ合わせて直積にしたものと考えることができ、ADTsで表現することができます。

ADTsを表現するためにScalaに最初から備わっている機能として、 *タプル* 、 *=Either=* 型 、 *クラス* 、 *=sealed trait=* などがあります。そしてshapelessは、ADTsを専門に扱うためのライブラリです。

まずはScalaに備わっているADTsをサポートするための機能がどのような性質を持つか復習しましょう。

*** <<scala-adts>>ScalaにおけるADTsをサポートする手段

この節では、shapelessの理解をより深めるために、Scalaで型を組み合わせるために用意されているいくつかの方法について復習します。

*タプル* は、複数の型を組み合わせて1つの型にします。タプル自体は最も単純な型構築子[fn::値を持ちうる通常の意味での型ではなく、型を代入することで型を生成する、関数のような型のことを型構築子(型コンストラクタ)と呼びます。]の一つであり、それ自体多くの機能を持ちませんが、複数の型を一つにし、それをまた分解できるという最も基本的な機能を提供します。

#+begin_example scala
type StringIntTuple = Tuple2[String, Int]
/* もしくは */
type StringIntTuple = (String, Int)
val tupled: StringIntTuple = ("hoge", 42)
tupled._1 // => "hoge"
tupled._2 // => 42
#+end_example

*=Either=* も複数の型を組み合わせて1つの型にしますが、タプルとは違い、どちらかの型であることを表現します。
実際に値を入れたり取り出したりする際には、 =Left= と =Right= とを用いてどちらの型かを教えます:

#+begin_example scala
type StringIntEither = Either[String, Int]
val l: StringIntEither = Left("hoge")
val r: StringIntEither = Right(42)
#+end_example

*クラス* は、ある意味タプルの強化版です。なぜなら、複数の型を名前付きのフィールドとして持ち、さらに手続きをメソッドとして持っているからです:

#+begin_example scala
case class FooClass(s: String, i: Int) {
  def toString(): String = s"s: $s, i: $i"
}
#+end_example

*=sealed trait=* もまた、 =Either= の強化版です。なぜなら、 =Either= が提供する「型を選ぶ」という機能に付け加えて、それぞれの名前が提供されるからです。

Scalaユーザにとってお馴染の =Option= も =sealed trait= で実装されています:

#+begin_example scala
sealed trait Option[+A]
case class Some[+A](x: A) extends Option[A]
case object None extends Option[Nothing]
#+end_example

*Scalaには複数の型を組み合わせて1つにするための機能がいくつも用意されている* ことが分かりましたね。

それぞれの機能には以下のような共通点があることを確認してください:

- 名前を付けられるものと、付けられないものがある。
  - 名前を付けられる: クラス、 =sealed trait=
  - 名前を付けられない: =Tuple= 、 =Either=
- 3つ以上の型を組み合わせられるものと、組み合わせられないものがある。
  - 組み合わせられる: =Tuple= (ただし、 =Tuple22= までしか用意されていないので22個が上限)、クラス、 =sealed trait=
  - 組み合わせられない: =Either=

*** Shapeless

[[scala-adts][前項]]では、Scalaの言語機能でもある程度ADTsを実装できることを示しました。しかしながら、Scalaの標準言語機能のみを使ってADTsを実装する場合、以下のような制約が伴います:

- =Tuple= が22要素までにしか対応しておらず、これを超えるような直積をともなうADTsを表現できない。
- =TupleN= と =TupleN-1= , =TupleN+1= との間に型的な関連がほぼ無いため、相互運用性が低い。
- クラスや =sealed trait= を用いたADTsは、型が具体的すぎるため柔軟性が低い。
- =Either= は2要素にしか対応しておらず、2要素を越えるADTsを表現するためには複数の =Either= を組み合わせる必要があるが、その運用は複雑を極める。

** HList, HNil

Shapelessで直積を表現するには、 *=HList=* データ型を使います。 =HList= は、[[scala-adts][前項]]で登場したタプルと似た振舞いをします。つまり、複数の型を1つにし、その値が両方の型の値を持つことを保証します。

<<<=HList= を構築>>>するには、 =::= を型の間に置き、最後に *=HNil=* を置きます。
=::= は、型構築子としても、値構築子としても使うことができます。

#+begin_example scala
import shapeless.{::, HNil}
type IntStringHList = Int :: String :: HNil // (Int, String) にほぼ対応する
val hlis: IntStringHList = 42 :: "foo" :: HNil
// hlis: shapeless.::[Int, shapeless.::[String, HNil]] = 42 :: "foo" :: HNil
#+end_example

=::= と =HNil= は =HList= のサブタイプです。

#+begin_example scala
val hlis: HList = 10 :: "bar" :: HNil
val hn: HList = HNil
#+end_example

形が分かっている =HList= からは型安全に値を取り出すことができます:

#+begin_example scala
def stringifyIntString(is: IntStringHList): String = {
  val i = is.head      // type safe -- 常にInt
  val s = is.tail.head // type safe -- 常にString
  ...
}
#+end_example

=match= 式で内容を取り出すこともできます:

#+begin_example scala
hlis match {
  case (i: Int) :: (s: String) :: HNil => s"int: $i, string: $s"
} // => "int: 42, string: foo"
#+end_example

*** 型の中置記法

冒頭で示したコードのうち、返り値の型に注目してください。

#+begin_example scala
val hlis: IntStringHList = 42 :: "foo" :: HNil
// hlis: shapeless.::[Int, shapeless.::[String, HNil]] = 42 :: "foo" :: HNil
#+end_example

=shapeless.::[Int, shapeless.::[String, HNil]]= がリストのような形式になっているのが分かるはずです。
Scalaには2-arityの型を中置する記法がある[fn::https://stackoverflow.com/questions/33347955/real-life-examples-of-scala-infix-types に型中置の事例が紹介されています。]ため、これを =Int :: String :: HNil= と書けるのです。

#+BEGIN_SRC dot :file hlist.png :exports results :cache yes
  digraph {
    is[label="::"];
    i[label="Int"];
    sh[label="::"];
    s[label="String"];
    h[label="HNil"];
    is -> i[label="head"];
    is -> sh[label="tail"];
    sh -> s[label="head"];
    sh -> h[label="tail"];
  }
#+END_SRC

#+RESULTS[1259b5d991ffb75a6fd23671e1565095c737c2bd]:
[[file:hlist.png]]

*** case class との違い

先程の =hlis= とほぼ同じ内容のものを =case class= で作成して比較してみます。

#+begin_example scala
case class Hlis(first: Int, second: String)
val hlis2 = Hlis(42, "foo")
#+end_example

=case class= で作った =hlis2= は、 =Hlis= という固有のクラス名・フィールド名を持っています。 =hlis= は =HList=
である以外に何も情報を持ちません。いくつかの性質を表にまとめました:

| 性質                         | case class | HList | Tuple |
|------------------------------+------------+-------+-------|
| いくつでもフィールドを持てる | true       | true  | false |
| 型が固有名を持つ             | true       | false | false |
| 型がフィールド名を持つ       | true       | false | false |

=HList= は、 =case class= ほど強い表現力を持たない代わりに、強い柔軟性を持つことができています。

** Coproduct

Shapelessで直和を表現するには、 *=Coproduct=* データ型を使います。 =Coproduct= は、[[scala-adts][前項]]で登場した =Either= と似た振舞いをします。つまり、複数の型を1つにし、その値がどちらかの型の値を持つことを保証します。

<<<=Coproduct= を構築>>>するには、 =:+:= を型の間に置き、最後に =CNil= を置きます。

#+begin_example scala
import shapeless.{:+:, CNil}
type IntOrString = Int :+: String :+: CNil // Either[Int, String]にほぼ対応する
#+end_example

=Coproduct= は =Either= と異なり、リスト状の構造になっています:

#+BEGIN_SRC dot :file coproduct.png :exports results :cache yes
  digraph {
    is[label=":+:"];
    i[label="Int"];
    sc[label=":+:"];
    s[label="String"];
    c[label="CNil"];
    is -> i[label="Inl"];
    is -> sc[label="Inr"];
    sc -> s[label="Inl"];
    sc -> c[label="Inr"];
  }
#+END_SRC

#+RESULTS[5571865644b10ef1dab58257925d01a69f6141c8]:
[[file:coproduct.png]]

このため、 _=Coproduct= は3つ以上の型を自然に組み合わせることができます。_

*** Inl / Inr

=Coproduct= の値構築子は =Inl= と =Inr= です[fn::Inは *Injection* の略で、圏論の用語に由来しています。型A, Bのそれぞれから余積A+Bに写すような射のことをCanonical injection(標準入射)と呼びます。 https://ja.wikipedia.org/wiki/%E4%BD%99%E7%A9%8D 。個人的には非常に難解な名付けで、良くないと思っています。]。これは =Either= における =Left= と =Right= に対応します。

#+begin_example scala
import shapeless.{Inl, Inr}
val i: IntOrString = Inl(42) // Left(42) に対応する
val s: IntOrString = Inr(Inl("foo")) // Right("foo")に対応する
#+end_example

=Inl= と =Inr= の唯一の役割は、元々のプリミティブな値を =Coproduct= の型の文脈に押し上げることです。言い換えると、型レベルの標識を行い、単なる =Int= なのか、それとも =Int :+: String :+: CNil= 上の =Int= なのかを区別させるためだけに存在しています。

さっきのは /MT免許/ です。 /AT免許/ として =Inject= が用意されています。 =Inl= や =Inr= を省略できます:

#+begin_example scala
import shapeless.syntax.inject._
val s2: IntOrString = "foo".inject[IntOrString] // => Inr(Inl("foo"))
// これは以下の表現と等価
import shapeless.ops.coproduct.Inject
val s3: IntOrString = Inject[IntOrString, String].apply("foo")
#+end_example

先程も述べた通り、 =Coproduct= が =Either= よりも優れている点として、 _3つ以上の型を自然に組み合わせられる_ というものがあります。

#+begin_example scala
case class ErrorA(msg: String)
case class ErrorB(msg: String)
case class ErrorC(msg: String)
case class ErrorD(msg: String)
type Errors = ErrorA :+: ErrorB :+: ErrorC :+: ErrorD :+: CNil

val ec: Errors = ErrorC("injecting").inject[Errors] // => Inr(Inr(Inl(ErrorC(...))))
#+end_example

=Either= でも似たような事はできますが、結合順序の定義が悪いため =Coproduct= ほど洗練された定義を与えられません。

*** Inl / Inr 補足

これは補足なのでスキップしてかまいません。

=Coproduct= が右向きのリスト状に構成されている都合上、 =Inl= は常に値を保持する役回りであり、 =Inl= は型を1つずらす操作に対応します。このため、 =Coproduct= の値表現は常に =Inr(...(Inl(値)))= という表現になります。この感覚には少し慣れが必要です。というのも、 =HList= の場合は順番が重要であることは直感的に理解できる一方で、 =Coproduct= で順番を気にしなければならないことは直感的ではないからです(実際、 =sealed trait= では順番を気にする必要がありません)。

=HList= の値を構築したときは複数の束ねたい型と唯一の値構築子 =::= を用いましたが、 =Coproduct= の場合は渡す型は一つだけであり、 =Coproduct= のどの型にあてはまるかを指示するために =Inl= と =Inr= という型構築子を使い分けます[fn::この面白い対称関係は、直積と余積が圏論的双対になっていることに由来するものだと思いますが、専門家ではないのでわかりません。]。

リボルバー銃の弾倉を回す操作と、引き金を引く操作になぞらえると分かりやすいかもしれません。必要な数だけ弾倉を回し、引き金を引くことで望みの型が飛び出すのです。

** Record

前項では、 =HList= を構築する方法と =Coproduct= を構築する方法について学びました。ここでは =HList= にフィールド名の概念を追加した Record について学びます。

Recordはちょうど型安全でポリモーフィックな =Map= のように振舞い、フィールド名を用いて型安全に値を取り出すことができます。Rubyといった言語の連想配列が、さらに型安全になった様子をイメージすると分かりやすいと思います。

*** Recordを作る

=HList= を構築する方法と =->>= とを組み合わせることで、<<<=Record= を構築する>>>ことができます。

#+begin_example
import shapeless.syntax.singleton._ // ->>のために必要
val hashFoo = ("foo" ->> "bar") :: ("hoge" ->> 42) :: HNil // フィールド"foo"と"bar"を持つRecordを作成
#+end_example

Recordの型は、 =FieldType[K, V]=
[fn::https://github.com/milessabin/shapeless/blob/417d34b7f30b8be89a80fca7802c159aedac85f5/core/shared/src/main/scala/shapeless/labelled.scala#L25]を集めた =HList= になります。
上の例では、 =hashFoo= の型は =FieldType[String, String] :: FieldType[String, Int] :: HNil= です。

** 任意のADTsに対して操作を定義する

*** Generic

* 参考文献

** <<underscoreio>>The Type Astronaut's Guide to Shapeless

underscoreioによる [[https://underscore.io/books/shapeless-guide/][The Type Astronaut's Guide to Shapeless]] (英語) はshapelessの仕組みを順に解説してくれる良著です。shapelessの各構成要素について知りたい場合は必ず読むと良いでしょう。

#+begin_export html
<script>
console.log('highlighting codes');
hljs.configure({
  languages: ['scala'],
  cssSelector:'pre'
})
hljs.highlightAll();
</script>
#+end_export
